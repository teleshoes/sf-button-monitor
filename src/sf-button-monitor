#!/usr/bin/perl
use strict;
use warnings;
use Time::HiRes qw(time);

my $INPUT_DEV = "/dev/input/by-path/platform-gpio_keys.105-event";

my $PTRN_MAX_MILLIS = 350;
my $PTRN_ACCIDENTAL_DOUBLE_MILLIS = 10;

sub readButtonEvent($);
sub trimPattern(@);
sub removeAccidentalDoubleClicks(@);
sub formatPattern(@);
sub condensePattern(@);
sub checkAction(@);
sub allEq(@);
sub nowMillis();

my $usage = "Usage:
  Perform actions when Sailfish OS hardware buttons are pressed.

  Supports volume up/down and camera half/full keys,
    when screen is locked or unlocked.

  Can run arbitrary shell commands, or a few built-in commands.

  Works best with automatic display-on disabled (requires mcetool).
    Install mcetool and run the following,
    to prevent unlocking when camera/volume is pressed:
      mcetool --set-exception-length-volume=0
      mcetool --set-exception-length-camera=0

  $0 -h | --help
    display this message

  $0
    -listen to $INPUT_DEV
    -parse bytes into button press/release events
    -split sequences of events into patterns
    -perform actions that match event patterns and system conditions

  BTN_PTRN  = <EVENT> | <EVENT> <BTN_PTRN>
               a full pattern string containing button press/releases
  EVENT     = <PRESS> | <RELEASE> | <CLICK> | <GROUP>
                a button press and/or release
  PRESS     = <BTN>-press
                pressing button named <BTN>
  RELEASE   = <BTN>-press
                releasing button named <BTN>
  CLICK     = <BTN>
                same as: <BTN>-press <BTN>-release
  GROUP     = <BTN>() | <BTN>( <BTN_PTRN> )
                same as: <BTN>-press <BTN_PTRN> <BTN>-release
  BTN       = vu | vd | ch | cf
                the name of a physical hardware button
                  vu: volume up
                  vd: volume down
                  ch: camera half
                  cf: camera full

  BTN_PTRN is a sequence of button presses/releases, with optional short synonyms
  e.g.:
     vd-press vd-release =>
         vd-press vd-release
     vd =>
         vd-press vd-release
     vd() =>
         vd-press vd-release
     vd vd =>
         vd-press vd-release vd-press vd-release
     vd(vu) =>
         vd-press vu-press vu-release vd-release
     ch(vd vd(vu vu()) cf) =>
         ch-press vd-press vd-release vd-press
         vu-press vu-release vu-press vu-release
         vd-release cf-press cf-release ch-release
";

my @BUTTONS = (
  [qw(115 VOL_UP   vu)],
  [qw(114 VOL_DOWN vd)],
  [qw(16  CAM_HALF ch)],
  [qw(254 CAM_FULL cf)],
);
my %OK_BUTTON_IDS = map {$$_[0] => 1} @BUTTONS;
my %BTN_NAMES = map {$$_[0] => $$_[1]} @BUTTONS;
my %BTN_SHORTNAMES = map {$$_[0] => $$_[2]} @BUTTONS;

my $TYPE_PRESS = "press";
my $TYPE_RELEASE = "release";

sub main(@){
  if(@_ == 1 and $_[0] =~ /^(-h|--help)$/){
    print $usage;
    exit 0;
  }elsif(@_ > 0){
    die $usage;
  }

  #auto-flush stdout
  select(STDOUT);
  $| = 1;

  my $inputDevFH;
  my @pattern;
  my $lastButtonMillis = nowMillis();
  open $inputDevFH, "< $INPUT_DEV";
  while(1){
    my ($buttonId, $value) = readButtonEvent($inputDevFH);

    my $now = nowMillis();
    my $elapsedMillis = $now - $lastButtonMillis;
    $lastButtonMillis = $now;

    my $type = $value ? $TYPE_PRESS : $TYPE_RELEASE;

    my $event = {
      buttonId      => $buttonId,
      type          => $type,
      elapsedMillis => $elapsedMillis,
    };

    push @pattern, $event;
    @pattern = trimPattern @pattern;

    printf "EVENT: %8s => %-7s  %14dms  (%s)\n",
      $BTN_NAMES{$$event{buttonId}},
      $$event{type},
      $$event{elapsedMillis},
      formatPattern(@pattern),
      ;

    @pattern = removeAccidentalDoubleClicks(@pattern);

    my $command = checkAction(@pattern);
    if(defined $command){
      @pattern = ();
      system "$command &";
    }
  }
}

#blocks until a valid button press/release event and then returns it
sub readButtonEvent($){
  my ($inputDevFH) = @_;
  my $byteStr;
  while(1){
    read $inputDevFH, $byteStr, 16;
    my @bytesDec = map {ord $_} split //, $byteStr;
    my $buttonId = $bytesDec[10];
    my $value = $bytesDec[12];
    if(defined $OK_BUTTON_IDS{$buttonId}){
      return ($buttonId, $value);
    }
  }
}

sub trimPattern(@){
  my (@pattern) = @_;
  my %states = map {$_ => 0} sort keys %OK_BUTTON_IDS;
  my $trimIndex = 0;
  for(my $i=0; $i<@pattern; $i++){
    my $event = $pattern[$i];
    my $btnId = $$event{buttonId};
    my @keysDown = grep {$states{$_}} sort keys %states;
    if(@keysDown == 0 and $$event{elapsedMillis} > $PTRN_MAX_MILLIS){
      $trimIndex = $i;
    }
    if($$event{type} eq $TYPE_PRESS){
      if($states{$btnId} == 1){
        print "    WARNING: press without release for $BTN_NAMES{$btnId}\n";
        $trimIndex = $i+1;
      }
      $states{$$event{buttonId}} = 1;
    }elsif($$event{type} eq $TYPE_RELEASE){
      if($states{$btnId} == 0){
        print "    WARNING: release without press for $BTN_NAMES{$btnId}\n";
        $trimIndex = $i+1;
      }
      $states{$$event{buttonId}} = 0;
    }
  }

  if($trimIndex >= @pattern){
    @pattern = ();
  }elsif($trimIndex > 0){
    @pattern = @pattern[$trimIndex..$#pattern];
  }

  return @pattern;
}

sub removeAccidentalDoubleClicks(@){
  my @pattern = @_;
  my %dupeIndexes;
  for(my $i=0; $i<@pattern; $i++){
    last if $i > @pattern - 3;
    my $initPress = $pattern[$i];
    my $initRelease = $pattern[$i+1];
    my $dupePress = $pattern[$i+2];

    next if $$initPress{type} ne $TYPE_PRESS;
    next if $$initRelease{type} ne $TYPE_RELEASE;
    next if $$dupePress{type} ne $TYPE_PRESS;

    my @events = ($initPress, $initRelease, $dupePress);
    my @buttonIds = map {$$_{buttonId}} @events;
    next if not allEq(@buttonIds);

    next if $$initRelease{elapsedMillis} > $PTRN_ACCIDENTAL_DOUBLE_MILLIS;
    next if $$dupePress{elapsedMillis} > $PTRN_ACCIDENTAL_DOUBLE_MILLIS;

    $dupeIndexes{$i+1} = 1; #skip the initial release
    $dupeIndexes{$i+2} = 1; #skip the extra press
  }

  my $dupeIndexCount = keys %dupeIndexes;
  if($dupeIndexCount > 0){
    my @newPattern;
    for(my $i=0; $i<@pattern; $i++){
      if(not defined $dupeIndexes{$i}){
        push @newPattern, $pattern[$i];
      }
    }
    printf "    FALSE DBL CLICK: %s => %s\n",
      formatPattern(@pattern),
      formatPattern(@newPattern),
      ;
    @pattern = @newPattern;
  }

  return @pattern;
}

sub formatPattern(@){
  return join(" ", condensePattern(@_));
}

sub condensePattern(@){
  my @pattern = @_;
  return () if @pattern == 0;
  my $event = shift @pattern;
  my $btnShortName = $BTN_SHORTNAMES{$$event{buttonId}};
  if($$event{type} eq $TYPE_PRESS){
    for(my $i=0; $i<@pattern; $i++){
      my $btnRelEvent = $pattern[$i];
      next if $$btnRelEvent{buttonId} != $$event{buttonId};
      next if $$btnRelEvent{type} ne $TYPE_RELEASE;

      my @group = @pattern[0..$i-1];
      @pattern = @pattern[$i+1..$#pattern];

      if(@group > 0){
        return ("$btnShortName(", condensePattern(@group), ")", condensePattern(@pattern));
      }else{
        return ("$btnShortName", condensePattern(@pattern));
      }
    }
    return ("$btnShortName-press");
  }elsif($$event{type} eq $TYPE_RELEASE){
    return ("$btnShortName-release", condensePattern(@pattern));
  }else{
    die "INVALID EVENT TYPE: $$event{type}\n";
  }
}

sub checkAction(@){
  my @pattern = @_;
  print formatPattern(@pattern);

  ###HACK

  if(@pattern == 4){
    my ($p1, $r1, $p2, $r2) = @pattern;
    next if $$p1{value} != 1;
    next if $$r1{value} != 0;
    next if $$p2{value} != 1;
    next if $$r2{value} != 0;
    my @buttons = map {$$_{button}} @pattern;
    next if not allEq(@buttons);

    if($buttons[0] == 115){
      return "klomp-cmd pause";
    }elsif($buttons[0] == 114){
      return "flashlight-toggle";
    }
  }

  ###HACK
  return undef;
}

sub allEq(@){
  for my $elem(@_){
    my $first = $_[0];
    if($first ne $elem){
      return 0;
    }
  }
  return 1;
}

sub nowMillis(){
  return int(time * 1000.0 + 0.5);
}

&main(@ARGV);
