#!/usr/bin/perl
use strict;
use warnings;
use Time::HiRes qw(time);

my $PTRN_MAX_MILLIS = 350;
my $PTRN_ACCIDENTAL_DOUBLE_MILLIS = 10;

sub trimPattern(@);
sub removeAccidentalDoubleClicks(@);
sub formatPattern(@);
sub checkAction(@);
sub allEq(@);
sub nowMillis();

my $BUTTONS = {
  115 => "VOL_UP",
  114 => "VOL_DOWN",
  16  => "CAM_HALF",
  254 => "CAM_FULL",
};

sub main(@){
  open FH, "< /dev/input/by-path/platform-gpio_keys.105-event";
  my $byteStr;
  my @pattern;
  my $stdOut = select();
  my $lastButtonMillis = nowMillis();
  while(1){
    read FH, $byteStr, 16;
    my @bytesDec = map {ord $_} split //, $byteStr;
    my $button = $bytesDec[10];
    my $value = $bytesDec[12];
    if(defined $$BUTTONS{$button}){
      my $now = nowMillis();
      my $elapsed = $now - $lastButtonMillis;
      $lastButtonMillis = $now;
      print "BUTTON: $$BUTTONS{$button} => $value (${elapsed}ms)\n";
      $stdOut->flush();

      my $event = {
        button => $button,
        value => $value,
        elapsed => $elapsed,
      };
      push @pattern, $event;
      @pattern = trimPattern @pattern;

      my $command = checkAction(@pattern);
      if(defined $command){
        @pattern = ();
        system "$command &";
      }
    }
  }
}

sub trimPattern(@){
  my (@pattern) = @_;
  my %states = map {$_ => 0} sort keys %$BUTTONS;
  my $trimIndex = 0;
  for(my $i=0; $i<@pattern; $i++){
    my $event = $pattern[$i];
    my @keysDown = grep {$states{$_}} sort keys %states;
    if(@keysDown == 0 and $$event{elapsed} > $PTRN_MAX_MILLIS){
      $trimIndex = $i;
    }
    $states{$$event{button}} = $$event{value};
  }
  if($trimIndex > 0){
    @pattern = @pattern[$trimIndex..$#pattern];
  }

  @pattern = removeAccidentalDoubleClicks(@pattern);
  return @pattern;
}

sub removeAccidentalDoubleClicks(@){
  my @pattern = @_;
  my %dupeIndexes;
  for(my $i=0; $i<@pattern; $i++){
    last if $i > @pattern - 3;
    my $initPress = $pattern[$i];
    my $initRelease = $pattern[$i+1];
    my $dupePress = $pattern[$i+2];

    next if $$initPress{value} != 1;
    next if $$initRelease{value} != 0;
    next if $$dupePress{value} != 1;

    my @events = ($initPress, $initRelease, $dupePress);
    my @buttons = map {$$_{button}} @events;
    next if not allEq(@buttons);

    next if $$initRelease{elapsed} > $PTRN_ACCIDENTAL_DOUBLE_MILLIS;
    next if $$dupePress{elapsed} > $PTRN_ACCIDENTAL_DOUBLE_MILLIS;

    print "    ACCIDENTAL DOUBLE-CLICK DETECTED: $$initPress{button}\n";
    select()->flush();
    $dupeIndexes{$i+1} = 1; #skip the initial release
    $dupeIndexes{$i+2} = 1; #skip the extra press
  }

  my $dupeIndexCount = keys %dupeIndexes;
  if($dupeIndexCount > 0){
    my @newPattern;
    for(my $i=0; $i<@pattern; $i++){
      if(not defined $dupeIndexes{$i}){
        push @newPattern, $pattern[$i];
      }
    }
    @pattern = @newPattern;
  }

  return @pattern;
}

sub formatPattern(@){
  my @eventFmts;
  my @pattern = @_;
  for my $event(@pattern){
    my $button = $$event{button};
    my $buttonName = $$BUTTONS{$button};
    if($$event{value}){
      push @eventFmts, $buttonName;
    }else{
      push @eventFmts, lc $buttonName;
    }
  }

  return "  @eventFmts\n";
}

sub checkAction(@){
  my @pattern = @_;
  print formatPattern(@pattern);
  select()->flush();
  return undef;
}

sub allEq(@){
  for my $elem(@_){
    my $first = $_[0];
    if($first ne $elem){
      return 0;
    }
  }
  return 1;
}

sub nowMillis(){
  return int(time * 1000.0 + 0.5);
}

&main(@ARGV);
