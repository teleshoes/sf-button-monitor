#!/usr/bin/perl
use strict;
use warnings;
use Time::HiRes qw(time);

my $INPUT_DEV = "/dev/input/by-path/platform-gpio_keys.105-event";

my $PTRN_MAX_MILLIS = 350;
my $PTRN_ACCIDENTAL_DOUBLE_MILLIS = 10;

sub readButtonEvent($);
sub trimPattern(@);
sub removeAccidentalDoubleClicks(@);
sub formatPattern(@);
sub checkAction(@);
sub allEq(@);
sub nowMillis();

my $usage = "Usage:
  Perform actions when Sailfish OS hardware buttons are pressed.

  Supports volume up/down and camera half/full keys,
    when screen is locked or unlocked.

  Can run arbitrary shell commands, or a few built-in commands.

  Works best with automatic display-on disabled (requires mcetool).
    Install mcetool and run the following,
    to prevent unlocking when camera/volume is pressed:
      mcetool --set-exception-length-volume=0
      mcetool --set-exception-length-camera=0

  $0 -h | --help
    display this message

  $0
    -listen to $INPUT_DEV
    -parse bytes into button press/release events
    -split sequences of events into patterns
    -perform actions that match event patterns and system conditions
";

my $BUTTONS = {
  115 => "VOL_UP",
  114 => "VOL_DOWN",
  16  => "CAM_HALF",
  254 => "CAM_FULL",
};

sub main(@){
  if(@_ == 1 and $_[0] =~ /^(-h|--help)$/){
    print $usage;
    exit 0;
  }elsif(@_ > 0){
    die $usage;
  }

  #auto-flush stdout
  select(STDOUT);
  $| = 1;

  my $inputDevFH;
  my @pattern;
  my $lastButtonMillis = nowMillis();
  open $inputDevFH, "< $INPUT_DEV";
  while(1){
    my ($button, $value) = readButtonEvent($inputDevFH);

    my $now = nowMillis();
    my $elapsed = $now - $lastButtonMillis;
    $lastButtonMillis = $now;
    print "BUTTON: $$BUTTONS{$button} => $value (${elapsed}ms)\n";

    my $event = {
      button => $button,
      value => $value,
      elapsed => $elapsed,
    };
    push @pattern, $event;
    @pattern = trimPattern @pattern;

    my $command = checkAction(@pattern);
    if(defined $command){
      @pattern = ();
      system "$command &";
    }
  }
}

#blocks until a valid button press/release event and then returns it
sub readButtonEvent($){
  my ($inputDevFH) = @_;
  my $byteStr;
  while(1){
    read $inputDevFH, $byteStr, 16;
    my @bytesDec = map {ord $_} split //, $byteStr;
    my $button = $bytesDec[10];
    my $value = $bytesDec[12];
    if(defined $$BUTTONS{$button}){
      return ($button, $value);
    }
  }
}

sub trimPattern(@){
  my (@pattern) = @_;
  my %states = map {$_ => 0} sort keys %$BUTTONS;
  my $trimIndex = 0;
  for(my $i=0; $i<@pattern; $i++){
    my $event = $pattern[$i];
    my @keysDown = grep {$states{$_}} sort keys %states;
    if(@keysDown == 0 and $$event{elapsed} > $PTRN_MAX_MILLIS){
      $trimIndex = $i;
    }
    $states{$$event{button}} = $$event{value};
  }
  if($trimIndex > 0){
    @pattern = @pattern[$trimIndex..$#pattern];
  }

  @pattern = removeAccidentalDoubleClicks(@pattern);
  return @pattern;
}

sub removeAccidentalDoubleClicks(@){
  my @pattern = @_;
  my %dupeIndexes;
  for(my $i=0; $i<@pattern; $i++){
    last if $i > @pattern - 3;
    my $initPress = $pattern[$i];
    my $initRelease = $pattern[$i+1];
    my $dupePress = $pattern[$i+2];

    next if $$initPress{value} != 1;
    next if $$initRelease{value} != 0;
    next if $$dupePress{value} != 1;

    my @events = ($initPress, $initRelease, $dupePress);
    my @buttons = map {$$_{button}} @events;
    next if not allEq(@buttons);

    next if $$initRelease{elapsed} > $PTRN_ACCIDENTAL_DOUBLE_MILLIS;
    next if $$dupePress{elapsed} > $PTRN_ACCIDENTAL_DOUBLE_MILLIS;

    print "    ACCIDENTAL DOUBLE-CLICK DETECTED: $$initPress{button}\n";
    $dupeIndexes{$i+1} = 1; #skip the initial release
    $dupeIndexes{$i+2} = 1; #skip the extra press
  }

  my $dupeIndexCount = keys %dupeIndexes;
  if($dupeIndexCount > 0){
    my @newPattern;
    for(my $i=0; $i<@pattern; $i++){
      if(not defined $dupeIndexes{$i}){
        push @newPattern, $pattern[$i];
      }
    }
    @pattern = @newPattern;
  }

  return @pattern;
}

sub formatPattern(@){
  my @eventFmts;
  my @pattern = @_;
  for my $event(@pattern){
    my $button = $$event{button};
    my $buttonName = $$BUTTONS{$button};
    if($$event{value}){
      push @eventFmts, $buttonName;
    }else{
      push @eventFmts, lc $buttonName;
    }
  }

  return "  @eventFmts\n";
}

sub checkAction(@){
  my @pattern = @_;
  print formatPattern(@pattern);

  ###HACK

  if(@pattern == 4){
    my ($p1, $r1, $p2, $r2) = @pattern;
    next if $$p1{value} != 1;
    next if $$r1{value} != 0;
    next if $$p2{value} != 1;
    next if $$r2{value} != 0;
    my @buttons = map {$$_{button}} @pattern;
    next if not allEq(@buttons);

    if($buttons[0] == 115){
      return "klomp-cmd pause";
    }elsif($buttons[0] == 114){
      return "flashlight-toggle";
    }
  }

  ###HACK
  return undef;
}

sub allEq(@){
  for my $elem(@_){
    my $first = $_[0];
    if($first ne $elem){
      return 0;
    }
  }
  return 1;
}

sub nowMillis(){
  return int(time * 1000.0 + 0.5);
}

&main(@ARGV);
